
.位模式 32

∥4个符号指令的测试文件

∥这个程序只是用来测试指令是否正确编译
∥不要运行这个程序，因为这个程序的指令是无序排列的
∥请使用反汇编工具查看指令编译后的代码


∥代码段开始


∥开始函数定义
∏主函数()
{
∥「
∥4个符号指令
§C∠1             ∥STC                标志寄存器的进位标志位置1
§D∠1             ∥STD                标志寄存器的方向标志位置1
§I∠1             ∥STI                标志寄存器的中断标志位置1
§C∠0             ∥CLC                标志寄存器进位位 清0
§D∠0             ∥CLD                标志寄存器方向位 清0
§I∠0             ∥CLI                标标志寄存器中断位 清0
累加16 = 累加低<±     ∥CBW                AL  符号扩展到 AX    
累加32 = 累加16<±     ∥CWDE               AX  符号扩展到 EAX
数据16 = 累加高<±     ∥MOVSX dx,ah        8位寄存器  符号扩展传送到 16位寄存器 
基数32 = 计数高<±     ∥MOVSX ebx,ch       8位寄存器  符号扩展传送到 32位寄存器 
基数32 = 源址16<±     ∥MOVSX ebx,si       16位寄存器 符号扩展传送到 32位寄存器 
计数16 = 基数高<◎     ∥MOVZX cx,ah        8位寄存器  带0扩展传送到  16位寄存器
基数32 = 计数低<◎     ∥MOVZX ebx,cl       8位寄存器  带0扩展传送到  32位寄存器 
基数32 = 的址16<◎     ∥MOVZX ebx,di       16位寄存器 带0扩展传送到  32位寄存器 

∥浮点
浮0 ∞ 浮1≯       ∥FCOMP              ST0 比较 ST1 并出栈
浮0 ∞ 浮1≯≯     ∥FCOMPP             ST0 比较 ST1 并出栈2次
浮0 ∝ 浮1≯       ∥FUCOMP             ST0 无序比较 ST1 并出栈
浮0 ∝ 浮1≯≯     ∥FUCOMPP            ST0 无序比较 ST1 并出栈2次
浮0 ∞ 浮2≯       ∥FCOMP ST2          ST0 比较 ST(i) 并出栈
浮0 ∞§ 浮3≯     ∥FCOMIP ST0,ST3     ST0 比较 ST(i) 装入标志寄存器 并出栈
浮0 ∝§ 浮4≯     ∥FUCOMIP ST0,ST4    ST0 比较 ST(i) 检查排序值(PF) 装入标志寄存器 并出栈
浮0 ∝ 浮5≯       ∥FUCOMP ST5         ST0 无序比较 ST(i) 并出栈
浮1   += 浮0≯     ∥FADDP              ST1   += ST0 并出栈
浮1  ÷= 浮0≯     ∥FDIVP              ST1  ÷= ST0 并出栈
浮1  ×= 浮0≯     ∥FMULP              ST1  ×= ST0 并出栈
浮1  -= 浮0≯      ∥FSUBP              ST1  -= ST0 并出栈
浮4 += 浮0≯       ∥FADDP ST4,ST0      ST(i) += ST0 并出栈
浮5 ÷= 浮0≯      ∥FDIVP ST5,ST0      ST(i) ÷= ST0 并出栈
浮6 ×= 浮0≯      ∥FMULP ST6,ST0      ST(i) ×= ST0 并出栈
浮7 = 浮0≯        ∥FSTP ST7           将ST0 复制到 ST(i) 并出栈
浮3 -= 浮0≯       ∥FSUBP ST3,ST0      ST(i) -= ST0 并出栈

∥」

}

 ∥代码段结束